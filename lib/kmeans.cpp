#include "Matrix.h"#include <set>#include <vector>#include <cmath>#include <cstdlib>using namespace std;struct RGB{	double R,G,B;	RGB(){R=B=G=0;};	RGB(double r, double g, double b){	R=r;	G=g;	B=b;	};RGB multiplyRGB(double mult){	return RGB(R*mult, G*mult, B*mult);};RGB addRGB(RGB rhs){	return RGB(R+rhs.R, G+rhs.G, B+rhs.B);};RGB operator+(const RGB &rhs) const{RGB ret = RGB(R,G,B);	ret.R+=rhs.R;	ret.G+=rhs.G;	ret.B+=rhs.B;	return ret;	};RGB operator*(double rhs) const{RGB ret = RGB(R,G,B);	ret.R*=rhs;	ret.G*=rhs;	ret.B*=rhs;	return ret;	};};double log2(double x){return log(x)/log(2);}void printRGB(RGB x){cerr<<"("<<x.R<<", "<<x.G<<", "<<x.B<<")\n";}double rgbDist(RGB a, RGB b){return abs((a.R - b.R)*(a.R - b.R)+(a.G - b.G)*(a.G - b.G)+(a.B - b.B)*(a.B - b.B));}double Order1RGBDist(RGB a, RGB b){return abs((a.R - b.R)+(a.G - b.G)+(a.B - b.B));}int calcMinRGBDist(RGB x, RGB * means, int k){double min = 1.0/0;;//Larger than any legal distanceint ret = -1;for(int i = 0; i < k; ++i){	double temp = rgbDist(x, means[i]);	if(min > temp){ ret = i;min = temp;}}return ret;} Matrix imageKMeans(Matrix & img, int k){//So first, we need to establish the means.//We'll do this systematically based on k.srand(time(0));RGB * means;int imgr = img.getRow(), imgc = img.getCol();means = new RGB[k];Matrix classes(img.getRow(), 1);double step = pow(2, log2(256)- log2(k));for(int i = 0; i < k; ++i){means[i] = RGB(i*step, i*step, i*step);//cout<<"means["<<i<<"] = ";printRGB(means[i]);}int formerClass = -1;bool changed = true;int iterations = -1;while (changed){changed = false;++iterations;for (int i = 0; i < imgr; ++i){		RGB temp(img(i, 0), img(i, 1), img(i, 2));		formerClass = classes(i, 0);		classes(i, 0)= calcMinRGBDist(temp, means, k);		if(formerClass != classes(i, 0)){			changed = true; 			//cout<<"former class was "<<formerClass<<"now "<<classes(i,0)<<endl;			}		}///Now recalculate means;for(int z = 0; z < k; ++z){//iterate through classesRGB tot(0,0,0);int count = 0;	for(int i = 0; i < imgr; ++i){			if(classes(i,0) != z) continue;			else{				++count;				tot.R += img(i, 0);				tot.G += img(i, 1);				tot.B += img(i, 2);				}					}	tot.R /= (count == 0? 1.0:(double)count);	tot.G /= (count == 0? 1.0:(double)count);	tot.B /= (count == 0? 1.0:(double)count);	if(count == 0) {	tot.R = rand()%256;	tot.G = rand()%256;	tot.B = rand()%256;	cerr<<"mean["<< z<< "] has 0 followers.  Randomly reassigning to "; printRGB(tot);	}	means[z].R = tot.R;	means[z].G = tot.G;	means[z].B = tot.B;	//	cout<<"Changed = "<<changed<<endl;} //End for z///Now, we just need to put the colors into the new matrix and return it}//End while, so the means aren't updating anymoreMatrix ret(imgr, imgc);	for(int i = 0; i < imgr; ++i){					int tempz = classes(i,0);			ret(i, 0) = (int) means[tempz].R;			ret(i, 1) = (int) means[tempz].G;			ret(i, 2) = (int) means[tempz].B;		}		cout<<"Iterations = "<<iterations<<endl;	delete[] means;	return ret;}
Matrix imageWinnerTakeAll(Matrix & img, int k){//So first, we need to establish the means.//We'll do this systematically based on k.srand(time(0));RGB * means;int imgr = img.getRow(), imgc = img.getCol();means = new RGB[k];Matrix classes(img.getRow(), 1);int * classCounts;classCounts = new int[k];double step = pow(2, log2(256)- log2(k));for(int i = 0; i < k; ++i){means[i] = RGB(i*step, i*step, i*step);classCounts[i] = 0;//cout<<"means["<<i<<"] = ";printRGB(means[i]);}int formerClass = -1;bool changed = true;int iterations = -1;while (changed){changed = false;iterations++;for(int i = 0; i < k; ++i){classCounts[i] = 0;}for (int i = 0; i < imgr; ++i){		RGB temp(img(i, 0), img(i, 1), img(i, 2));		int z;		formerClass = classes(i, 0);		z=classes(i, 0)= calcMinRGBDist(temp, means, k);		if(formerClass != classes(i, 0)){			classCounts[z]++;			RGB avg(means[z].R+temp.R/(classCounts[z]+1), 				means[z].G+temp.G/(classCounts[z]+1),				means[z].B+temp.B/(classCounts[z]+1));			changed = true; 			//cout<<"former class was "<<formerClass<<"now "<<classes(i,0)<<endl;			}		}///Now recalculate means;for(int z = 0; z < k; ++z){//iterate through classesRGB tot(0,0,0);int count = 0;	for(int i = 0; i < imgr; ++i){			if(classes(i,0) != z) continue;			else{				++count;				tot.R += img(i, 0);				tot.G += img(i, 1);				tot.B += img(i, 2);				}					}	tot.R /= (count == 0? 1.0:(double)count);	tot.G /= (count == 0? 1.0:(double)count);	tot.B /= (count == 0? 1.0:(double)count);	if(count == 0) {	tot.R = rand()%256;	tot.G = rand()%256;	tot.B = rand()%256;	cerr<<"mean["<< z<< "] has 0 followers.  Randomly reassigning to "; printRGB(tot);	}	means[z].R = tot.R;	means[z].G = tot.G;	means[z].B = tot.B;	//	cout<<"Changed = "<<changed<<endl;} //End for z///Now, we just need to put the colors into the new matrix and return it}//End while, so the means aren't updating anymoreMatrix ret(imgr, imgc);	for(int i = 0; i < imgr; ++i){					int tempz = classes(i,0);			ret(i, 0) = (int) means[tempz].R;			ret(i, 1) = (int) means[tempz].G;			ret(i, 2) = (int) means[tempz].B;		}	cout<<"Iterations = "<<iterations<<endl;	return ret;}double phi(int neighbor, int winner, double sigma){///Phi function from slide 16 double rawDist = (double)neighbor - (double)winner;rawDist *= rawDist;return exp(-1*rawDist/(sigma*sigma*2));}double epsilon(double k){///Monotonically decreasing function, 1/x is simplisticreturn 1.0/(1+k);}void updateWinner(int z, RGB * means, RGB x, double sigma, int tot, int k){///z = winner index, means = array of RGBs, x = current sample, ///tot = number of elements in means, k = number of iterationsfor(int i = 0; i < tot; ++i){//cout<<"means[i] "; printRGB(means[i]); //cout<<"-x=";printRGB(x*-1.0);//cout<<"epsilon = "<<epsilon(k)<<"phi = "<<phi(i, z, sigma)<<endl;RGB dist = (x.multiplyRGB(-1.0)+means[i]);//cout<<"Distance = "; printRGB(dist);double mult = epsilon(k)*phi(i, z, sigma);//cout<<"mult = "<<mult<<endl;means[i] = means[i] + dist.multiplyRGB(mult);	}}Matrix & imageKohonen(Matrix img, int k, double sigma){	srand(time(0));	RGB * means;	int imgr = img.getRow(), imgc = img.getCol();	means = new RGB[k];	Matrix classes(img.getRow(), 1);	int * classCounts;	classCounts = new int[k];	//Topology is linear, so the index of the mean serves as the coordinate	double step = pow(2, log2(256)- log2(k));	for(int i = 0; i < k; ++i){		means[i] = RGB(i*step, i*step, i*step);		classCounts[i] = 0;	}	int formerClass = -1;	bool changed = true;	int iterations = -1;	while (changed){		changed = false;		if(iterations++ > 249 || iterations > k*1.5) break;		for(int i = 0; i < k; ++i){		classCounts[i] = 0;		}		for (int i = 0; i < imgr; ++i){			RGB temp(img(i, 0), img(i, 1), img(i, 2));			int z;			formerClass = classes(i, 0);			//cout<<"Former class = "<<formerClass<<endl;			z=classes(i, 0)= calcMinRGBDist(temp, means, k);				classCounts[z]++;				if(formerClass != classes(i, 0)){					updateWinner(z, means, temp, sigma, iterations, k);					changed = true; 					//cout<<"now = "<<classes(i,0)<<endl;				}			}	///Now recalculate means;		for(int z = 0; z < k; ++z){//iterate through classes			RGB tot(0,0,0);			int count = 0;			for(int i = 0; i < imgr; ++i){				if(classes(i,0) != z) continue;				else{					++count;					tot.R += img(i, 0);					tot.G += img(i, 1);					tot.B += img(i, 2);					}				}			tot.R /= (count == 0? 1.0:(double)count);			tot.G /= (count == 0? 1.0:(double)count);			tot.B /= (count == 0? 1.0:(double)count);			if(count == 0) {				tot.R = rand()%256;				tot.G = rand()%256;				tot.B = rand()%256;				//cerr<<"mean["<< z<< "] has 0 followers.  Randomly reassigning to "; printRGB(tot);			}			means[z].R = tot.R;			means[z].G = tot.G;			means[z].B = tot.B;		//	cout<<"Changed = "<<changed<<endl;		} //End for z	}//End While		Matrix * ret = new Matrix(imgr, 3);	for(int i = 0; i < imgr; ++i){				int tempz = (int)(classes(i,0)< 0? 0: classes(i,0));			(*ret)(i, 0) = (int) (means[tempz].R< 0? 0:means[tempz].R);			(*ret)(i, 1) = (int) (means[tempz].G< 0? 0:means[tempz].G);			(*ret)(i, 2) = (int) (means[tempz].B< 0? 0:means[tempz].B);		}	cout<<"Iterations = "<<iterations<<endl;	return *ret;}